import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class Tag {
    private String namespace;
    private String value;
}

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.ArrayList;
import java.util.List;

@Data
@NoArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class FileEntry {
    private String path;
    private String newpath;
    private String contenttype;
    private String metadataForFile;

    private List<String> manualDependencies = new ArrayList<>();
    private List<String> scannedDependencies = new ArrayList<>();
    private List<String> manualDependenciesNewPaths = new ArrayList<>();
    private List<String> scannedDependenciesNewPaths = new ArrayList<>();

    private String description;
    private String author;

    private List<Tag> tags = new ArrayList<>();
    private boolean excluded;
}

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.ArrayList;
import java.util.List;

@Data
@NoArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class RootDoc {
    private List<FileEntry> files = new ArrayList<>();
    private List<String> packages = new ArrayList<>();
    private List<String> globalValues = new ArrayList<>();
}


import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class JsonVoWorkflow {

    private static final ObjectMapper MAPPER = new ObjectMapper()
            .enable(SerializationFeature.INDENT_OUTPUT);

    /**
     * JSON 파일을 VO로 읽고, files[templateIndex]를 복사하여 수정 후
     * files 배열의 마지막에 추가하고 저장합니다.
     */
    public static void appendFromTemplate(String inputPath, String outputPath, int templateIndex) throws Exception {
        // 1️⃣ JSON 파일 → VO 매핑
        RootDoc doc = MAPPER.readValue(new File(inputPath), RootDoc.class);

        if (doc.getFiles() == null || doc.getFiles().isEmpty()) {
            throw new IllegalStateException("'files' 배열이 비어 있습니다.");
        }
        if (templateIndex < 0 || templateIndex >= doc.getFiles().size()) {
            throw new IllegalArgumentException("templateIndex가 잘못되었습니다.");
        }

        // 2️⃣ 템플릿 복사 (깊은 복사)
        FileEntry template = doc.getFiles().get(templateIndex);
        FileEntry copy = deepCopy(template, FileEntry.class);

        // 3️⃣ 새로운 값 채우기 (실제 로직에 맞게 수정)
        copy.setPath("/new/path/example.txt");
        copy.setNewpath("/new/path/example.txt");
        copy.setContenttype("text/plain");
        copy.setMetadataForFile("meta info");
        copy.setDescription("자동 추가된 파일 블록");
        copy.setAuthor("kim.jy");
        copy.setExcluded(false);

        // 4️⃣ 배열 필드 새로 채우기
        copy.setManualDependencies(Arrays.asList("/lib/util.jar", "/lib/core.jar"));
        copy.setTags(Arrays.asList(
                new Tag("module", "core"),
                new Tag("purpose", "demo")
        ));

        // 5️⃣ files 배열 마지막에 추가
        doc.getFiles().add(copy);

        // (선택) 루트 레벨 수정도 가능
        // doc.setPackages(Arrays.asList("pkg-a","pkg-b"));
        // doc.setGlobalValues(Arrays.asList("G1","G2"));

        // 6️⃣ VO → JSON 파일로 다시 저장
        MAPPER.writeValue(new File(outputPath), doc);
        System.out.println("✅ files 항목 추가 완료: " + outputPath);
    }

    /** Jackson 기반 deep copy (레퍼런스 공유 방지) */
    public static <T> T deepCopy(Object src, Class<T> type) {
        return MAPPER.convertValue(src, type);
    }

    // 실행 테스트용 main
    public static void main(String[] args) {
        try {
            appendFromTemplate("input.json", "output.json", 0);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
